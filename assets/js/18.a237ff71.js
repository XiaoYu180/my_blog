(window.webpackJsonp=window.webpackJsonp||[]).push([[18],{496:function(e,t,s){e.exports=s.p+"assets/img/image-20220301011332858.d816d090.png"},497:function(e,t,s){e.exports=s.p+"assets/img/image-20220301011349841.11ad926f.png"},604:function(e,t,s){"use strict";s.r(t);var n=s(29),a=Object(n.a)({},(function(){var e=this,t=e.$createElement,n=e._self._c||t;return n("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[n("h1",{attrs:{id:"nginx配置websocket的wss访问"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#nginx配置websocket的wss访问"}},[e._v("#")]),e._v(" Nginx配置websocket的wss访问")]),e._v(" "),n("h2",{attrs:{id:"前景回顾"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#前景回顾"}},[e._v("#")]),e._v(" 前景回顾")]),e._v(" "),n("p",[e._v("最近自己的服务器需要上上线一个websocket服务，本地测试什么的都是正常的，知道上线的时候，发现报了如下错误")]),e._v(" "),n("p",[n("img",{attrs:{src:s(496),alt:"image-20220301011332858"}})]),e._v(" "),n("p",[e._v("从图中可以发现，如果内嵌websocket的站点是https加密的，则需要使用wss协议，而不是ws协议。毫无疑问我们就需要使用 wss:\\ 安全协议了，那不简单，直接把ws:\\ 改为 wss:\\ 不就行了？ 说干就干。")]),e._v(" "),n("p",[n("img",{attrs:{src:s(497),alt:"image-20220301011349841"}})]),e._v(" "),n("p",[e._v("好吧，还是太天真 上面的错误很明显 SSL 协议错误，说明就是证书问题了。测试的时候我们一直拿的是 IP地址 + 端口号 这种方式连接 WebSocket 的，所以一直不存在问题，但是生成环境我们肯定不能再用 IP地址 + 端口号这种形式了。看来简单的改协议头解决不了问题。那么怎么才能解决问题呢？")]),e._v(" "),n("h2",{attrs:{id:"方法一-nginx-配置域名支持-wss"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#方法一-nginx-配置域名支持-wss"}},[e._v("#")]),e._v(" 方法一：Nginx 配置域名支持 WSS")]),e._v(" "),n("div",{staticClass:"language- line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v('#在nginx内添加该段内容\nlocation /websocket {\n    proxy_pass http://backend;\n    proxy_http_version 1.1;\n    proxy_set_header Upgrade $http_upgrade;\n    proxy_set_header Connection "upgrade";\n}\n')])]),e._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[e._v("1")]),n("br"),n("span",{staticClass:"line-number"},[e._v("2")]),n("br"),n("span",{staticClass:"line-number"},[e._v("3")]),n("br"),n("span",{staticClass:"line-number"},[e._v("4")]),n("br"),n("span",{staticClass:"line-number"},[e._v("5")]),n("br"),n("span",{staticClass:"line-number"},[e._v("6")]),n("br"),n("span",{staticClass:"line-number"},[e._v("7")]),n("br")])]),n("p",[e._v("上文的具体作用就是将原来的websocket端口，挂载在https对应服务器下的/websocket路由下，"),n("a",{attrs:{href:"https://links.jianshu.com/go?to=http%3A%2F%2Fbackend",target:"_blank",rel:"noopener noreferrer"}},[e._v("http://backend"),n("OutboundLink")],1),e._v(" 就是你的websocket url 。这样就完成了，在 HTTPPS 下以域名方式连接 WebSocket。")]),e._v(" "),n("p",[n("strong",[e._v("稍微解释一下 Nginx 配置")])]),e._v(" "),n("p",[e._v("Nginx 自从 1.3 版本就开始支持 WebSocket 了，并且可以为 WebSocket 应用程序做反向代理和负载均衡。 WebSocket 和 HTTP 协议不同，但是 WebSocket 中的握手和 HTTP 中的握手兼容，它使用 HTTP 中的 Upgrade 协议头将连接从 HTTP 升级到 WebSocket，当客户端发过来一个 "),n("code",[e._v("Connection: Upgrade")]),e._v("请求头时，Nginx 是不知道的，所以，当 Nginx 代理服务器拦截到一个客户端发来的 "),n("code",[e._v("Upgrade")]),e._v(" 请求时，需要显式来设置"),n("code",[e._v("Connection")]),e._v(" 、"),n("code",[e._v("Upgrade")]),e._v(" 头信息，并使用 101（交换协议）返回响应，在客户端和代理服务器、后端服务器之间建立隧道来支持 WebSocket。")]),e._v(" "),n("p",[e._v("当然，还需要注意一下，WebSockets 仍然受到 Nginx 缺省为60秒的 proxy_read_timeout 的影响。这意味着，如果你有一个程序使用了 WebSockets，但又可能超过60秒不发送任何数据的话，那你要么需要增加超时时间，要么实现一个 ping 的消息以保持联系。使用 ping 的解决方法有额外的好处，可以发现连接是否被意外关闭。")]),e._v(" "),n("p",[e._v("更具体文档详见 Nginx 官方文档："),n("a",{attrs:{href:"https://links.jianshu.com/go?to=http%3A%2F%2Fnginx.org%2Fen%2Fdocs%2Fhttp%2Fwebsocket.html",target:"_blank",rel:"noopener noreferrer"}},[e._v("http://nginx.org/en/docs/http/websocket.html"),n("OutboundLink")],1)]),e._v(" "),n("h2",{attrs:{id:"方法二"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#方法二"}},[e._v("#")]),e._v(" 方法二：")]),e._v(" "),n("p",[e._v("这个方法就比较复杂了，需要在你的websocket服务器下加入证书支持。")]),e._v(" "),n("p",[e._v("这种方法，还是忽略就好。")])])}),[],!1,null,null,null);t.default=a.exports}}]);